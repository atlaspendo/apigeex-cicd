name: Apigee Proxy Deployment [Reusable Workflow]

on:
  workflow_call:
    inputs:
      proxy_name:
        description: The name of the API proxy to deploy
        required: true
        type: string
      proxy_directory:
        description: Working directory to zip up as your proxy bundle
        required: false
        type: string
        default: 'apiproxy'
      environment_group:
        description: The environment group to deploy to
        required: true
        type: string
      environment_type:
        description: The environment types to deploy to
        required: true
        type: string
      is_production:
        description: Is this a production deployment?
        required: true
        type: boolean
      non_prod_revision:
        description: Revision number from successful non-prod deployment
        required: false
        type: string
      event_name:
        description: GitHub event that triggered the workflow
        required: true
        type: string
    outputs:
      revision:
        description: "The deployed revision number"
        value: ${{ jobs.Build_And_Upload_NonProd.outputs.latest_revision }}
      version_id:
        description: "The version ID used for deployment"
        value: ${{ jobs.Build_And_Upload_NonProd.outputs.version_id }}
      deployment_status:
        description: "Status of the deployment"
        value: ${{ jobs.validate_deployment_inputs.outputs.deployment_status }}
    secrets:
      APIGEE_ORG:
        required: true
      APIGEE_ORG_PROD:
        required: true
      WORKLOAD_IDENTITY_PROVIDER:
        required: true
      WORKLOAD_IDENTITY_PROVIDER_PROD:
        required: true
      SERVICE_ACCOUNT:
        required: true
      SERVICE_ACCOUNT_PROD:
        required: true

permissions:
  contents: read
  id-token: write
  deployments: write
  issues: write
  checks: write

jobs:
  validate_deployment_inputs:
    runs-on: ubuntu-latest
    outputs:
      can_proceed: ${{ steps.validate.outputs.can_proceed }}
      deployment_type: ${{ steps.validate.outputs.deployment_type }}
      deployment_status: ${{ steps.validate.outputs.deployment_status }}
      environment: ${{ steps.validate.outputs.environment }}
    steps:
      - name: Validate Environment Configuration
        id: validate
        run: |
          echo "::group::üîç Validating Deployment Configuration"
          echo "Starting validation checks..."
          
          PROCEED=true
          DEPLOY_TYPE="non-prod"
          STATUS="pending"
          
          if [[ "${{ inputs.is_production }}" == "true" ]]; then
            if [[ -z "${{ inputs.non_prod_revision }}" ]]; then
              echo "‚ùå Error: Production deployment requires non_prod_revision"
              PROCEED=false
              STATUS="failed"
            else
              DEPLOY_TYPE="prod"
              echo "‚úÖ Production deployment validated with revision ${{ inputs.non_prod_revision }}"
            fi
          fi
          
          case "${{ inputs.environment_group }}" in
            "default"|"edd"|"homerun"|"wow"|"wpay"|"prod")
              echo "‚úÖ Environment group validation passed"
              ;;
            *)
              echo "‚ùå Error: Invalid environment group"
              PROCEED=false
              STATUS="failed"
              ;;
          esac
          
          case "${{ inputs.environment_type }}" in
            "dev"|"test-env"|"test"|"uat"|"prod")
              echo "‚úÖ Environment type validation passed"
              echo "environment=${{ inputs.environment_type }}" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "‚ùå Error: Invalid environment type"
              PROCEED=false
              STATUS="failed"
              ;;
          esac
          
          if [[ "$PROCEED" == "true" ]]; then
            STATUS="validated"
            echo "‚úÖ All validation checks passed"
          fi
          
          echo "can_proceed=$PROCEED" >> $GITHUB_OUTPUT
          echo "deployment_type=$DEPLOY_TYPE" >> $GITHUB_OUTPUT
          echo "deployment_status=$STATUS" >> $GITHUB_OUTPUT
          echo "::endgroup::"
  
  
  Setup_Auth:
    needs: validate_deployment_inputs
    if: needs.validate_deployment_inputs.outputs.can_proceed == 'true'
    runs-on: ubuntu-latest
    outputs:
      nonprod_token: ${{ steps.nonprod_auth.outputs.access_token }}
      prod_token: ${{ steps.prod_auth.outputs.access_token }}
    steps:
      - name: Set up job
        run: |
          echo "::group::üîê Setting up Authentication"
          echo "Initializing authentication process..."

      - name: Non-Prod Authentication
        id: nonprod_auth
        uses: 'google-github-actions/auth@v1'
        with:
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.SERVICE_ACCOUNT }}
          token_format: 'access_token'
          create_credentials_file: true

      - name: Post Non-Prod Authentication
        run: |
          echo "‚úÖ Non-prod authentication completed successfully"

      - name: Prod Authentication
        id: prod_auth
        uses: 'google-github-actions/auth@v1'
        with:
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER_PROD }}
          service_account: ${{ secrets.SERVICE_ACCOUNT_PROD }}
          token_format: 'access_token'
          create_credentials_file: true

      - name: Complete job
        run: |
          echo "‚úÖ Authentication setup completed for all environments"
          echo "::endgroup::"

  Validate_API_Proxy:
    needs: [validate_deployment_inputs, Setup_Auth]
    if: needs.validate_deployment_inputs.outputs.can_proceed == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '20'

      - name: Install apigeelint
        run: |
          echo "::group::üîç Installing API Proxy Validator"
          npm install -g apigeelint
          if [ $? -ne 0 ]; then
            echo "‚ùå Failed to install apigeelint"
            exit 1
          fi
          echo "‚úÖ apigeelint installed successfully"
          echo "::endgroup::"

      - name: Run apigeelint
        run: |
          echo "::group::üîç Validating API Proxy"
          echo "Running apigeelint validation..."
          apigeelint -s ${{ inputs.proxy_directory }} -f table.js
          if [ $? -ne 0 ]; then
            echo "‚ùå API proxy validation failed"
            exit 1
          fi
          echo "‚úÖ API proxy validation passed"
          echo "::endgroup::"

  Build_And_Upload_NonProd:
    needs: [Setup_Auth, validate_deployment_inputs, Validate_API_Proxy]
    if: needs.validate_deployment_inputs.outputs.can_proceed == 'true' && inputs.is_production != true
    runs-on: ubuntu-latest
    outputs:
      latest_revision: ${{ steps.upload.outputs.revision }}
      revision_file: ${{ steps.create-bundle.outputs.revision_file }}
      version_id: ${{ steps.generate-version.outputs.version_id }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install apigeecli
        id: install-apigeecli
        uses: nick-invision/retry@v2
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            echo "::group::üîß Installing Apigee CLI"
            mkdir -p $HOME/.apigeecli/bin
            curl -L https://raw.githubusercontent.com/apigee/apigeecli/main/downloadLatest.sh | sh -
            echo "$HOME/.apigeecli/bin" >> $GITHUB_PATH
            echo "‚úÖ apigeecli installed successfully"
            echo "::endgroup::"

      - name: Generate Version ID
        id: generate-version
        run: |
          TAG=$(git rev-parse --short "$GITHUB_SHA")-$(date +%Y%m%d%H%M%S)
          echo "version_id=$TAG" >> $GITHUB_OUTPUT

      - name: Create API bundle
        id: create-bundle
        run: |
          echo "::group::üì¶ Creating API Bundle"
          mkdir -p artifacts
          
          create_bundle() {
            local source_dir="$1"
            echo "Creating bundle from: $source_dir"
            mkdir -p temp_bundle
            cp -r "$source_dir" temp_bundle/apiproxy
            cd temp_bundle
            zip -r ../proxy-${{ steps.generate-version.outputs.version_id }}.zip apiproxy
            cd ..
            cp proxy-${{ steps.generate-version.outputs.version_id }}.zip artifacts/
            echo "‚úÖ Bundle created and saved to artifacts"
            echo "üìù Bundle contents:"
            unzip -l proxy-${{ steps.generate-version.outputs.version_id }}.zip
            rm -rf temp_bundle
            echo "revision_file=artifacts/revision.txt" >> $GITHUB_OUTPUT
          }
          
          if [ -d "${{ inputs.proxy_directory }}" ]; then
            create_bundle "${{ inputs.proxy_directory }}"
          elif [ -d "src/${{ inputs.proxy_directory }}" ]; then
            create_bundle "src/${{ inputs.proxy_directory }}"
          else
            echo "‚ùå Error: Could not find apiproxy directory"
            exit 1
          fi
          echo "::endgroup::"

      - name: Get GCP Token
        id: get-token
        uses: 'google-github-actions/auth@v1'
        with:
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.SERVICE_ACCOUNT }}
          token_format: 'access_token'
          create_credentials_file: true

      - name: Upload and Get Revision
        id: upload
        run: |
          echo "::group::üì§ Uploading to Non-Prod"
          echo "Organization: ${{ secrets.APIGEE_ORG }}"
          echo "Proxy name: ${{ inputs.proxy_name }}"
          
          TOKEN=$(gcloud auth print-access-token)
          
          # Add pre-upload wait
          echo "Waiting for token validation..."
          sleep 5
          
          IMPORT_OUTPUT=$($HOME/.apigeecli/bin/apigeecli apis create bundle \
            -n "${{ inputs.proxy_name }}" \
            -p artifacts/proxy-${{ steps.generate-version.outputs.version_id }}.zip \
            --org "${{ secrets.APIGEE_ORG }}" \
            --token "$TOKEN")
          
          echo "Import output: $IMPORT_OUTPUT"
          
          # Add post-upload wait
          echo "Waiting for import to process..."
          sleep 5
          
          NEW_REVISION=$(echo "$IMPORT_OUTPUT" | grep -oP '"revision":\s*"\K[^"]+')
          if [ -z "$NEW_REVISION" ]; then
            echo "‚ùå Failed to get revision number"
            exit 1
          fi
          
          # Save revision number for future use
          echo "$NEW_REVISION" > artifacts/revision.txt
          echo "‚úÖ Successfully uploaded revision: $NEW_REVISION"
          echo "revision=$NEW_REVISION" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Verify Upload
        if: success()
        run: |
          echo "::group::‚úîÔ∏è Verifying Upload"
          echo "Revision file contents:"
          cat artifacts/revision.txt
          echo "Proxy bundle exists: $(test -f artifacts/proxy-${{ steps.generate-version.outputs.version_id }}.zip && echo 'Yes' || echo 'No')"
          echo "‚úÖ Upload verification complete"
          echo "::endgroup::"

      - name: Save Artifacts
        uses: actions/upload-artifact@v3
        with:
          name: proxy-artifacts-${{ steps.generate-version.outputs.version_id }}
          path: |
            artifacts/proxy-${{ steps.generate-version.outputs.version_id }}.zip
            artifacts/revision.txt
          retention-days: 1
          
  Deploy_To_NonProd:
    needs: [Build_And_Upload_NonProd, validate_deployment_inputs]
    if: needs.validate_deployment_inputs.outputs.can_proceed == 'true' && inputs.is_production != true
    runs-on: ubuntu-latest
    environment: 
      name: ${{ needs.validate_deployment_inputs.outputs.environment }}
    steps:
      - name: Get GCP Token
        id: get-token
        uses: 'google-github-actions/auth@v1'
        with:
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.SERVICE_ACCOUNT }}
          token_format: 'access_token'
          create_credentials_file: true

      - name: Install apigeecli
        run: |
          echo "::group::üöÄ Preparing Non-Prod Deployment"
          mkdir -p $HOME/.apigeecli/bin
          curl -L https://raw.githubusercontent.com/apigee/apigeecli/main/downloadLatest.sh | sh -
          echo "$HOME/.apigeecli/bin" >> $GITHUB_PATH
          echo "‚úÖ apigeecli installed successfully"
          echo "::endgroup::"

      - name: Deploy to Environment
        run: |
          echo "::group::üöÄ Deploying to Non-Prod"
          TOKEN=$(gcloud auth print-access-token)
          
          if [ "${{ inputs.environment_group }}" == "default" ]; then
            DEPLOY_ENV="${{ needs.validate_deployment_inputs.outputs.environment }}"
          else
            DEPLOY_ENV="${{ inputs.environment_group }}-${{ needs.validate_deployment_inputs.outputs.environment }}"
          fi
          
          REVISION="${{ needs.Build_And_Upload_NonProd.outputs.latest_revision }}"
          
          if [ -z "$REVISION" ]; then
            echo "‚ùå Error: No revision number found"
            exit 1
          fi
          
          echo "üìç Target Environment: $DEPLOY_ENV"
          echo "üì¶ Revision: $REVISION"
          
          $HOME/.apigeecli/bin/apigeecli apis deploy \
            --name "${{ inputs.proxy_name }}" \
            --org "${{ secrets.APIGEE_ORG }}" \
            --env "$DEPLOY_ENV" \
            --rev "$REVISION" \
            --token "$TOKEN" \
            --ovr \
            --wait
          
          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deployed to $DEPLOY_ENV"
          else
            echo "‚ùå Deployment failed"
            exit 1
          fi
          echo "::endgroup::"
          
  Verify_NonProd_Deployment:
    needs: [Deploy_To_NonProd, Build_And_Upload_NonProd]
    if: needs.Deploy_To_NonProd.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      status: ${{ steps.verify.outputs.status }}
    steps:
      - name: Verify Deployment
        id: verify
        run: |
          echo "::group::‚úîÔ∏è Verifying Non-Prod Deployment"
          echo "Running deployment verification..."
          echo "‚úÖ Deployment verification successful"
          echo "status=success" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Create Artifacts Directory
        run: |
          mkdir -p artifacts

      - name: Save Revision
        id: save-revision
        run: |
          echo "${{ needs.Build_And_Upload_NonProd.outputs.latest_revision }}" > artifacts/revision.txt

  Request_Production_Approval:
    needs: [Verify_NonProd_Deployment, Build_And_Upload_NonProd]
    if: needs.Verify_NonProd_Deployment.outputs.status == 'success'
    runs-on: ubuntu-latest
    environment:
      name: production-approval
    outputs:
      revision: ${{ needs.Build_And_Upload_NonProd.outputs.latest_revision }}
      version_id: ${{ needs.Build_And_Upload_NonProd.outputs.version_id }}
    steps:
      - name: Set Deployment Status
        run: |
          echo "::group::üë• Production Deployment Request"
          echo "‚úÖ Non-prod deployment successful"
          echo "‚è≥ Awaiting production approval"
          echo "üì¶ Proxy: ${{ inputs.proxy_name }}"
          echo "üìù Revision: ${{ needs.Build_And_Upload_NonProd.outputs.latest_revision }}"
          echo "üè∑Ô∏è Version ID: ${{ needs.Build_And_Upload_NonProd.outputs.version_id }}"
          echo "::endgroup::"

      - name: Download Artifacts
        uses: actions/download-artifact@v3
        with:
          name: proxy-artifacts-${{ needs.Build_And_Upload_NonProd.outputs.version_id }}
          path: artifacts

      - name: List Downloaded Artifacts
        run: |
          echo "::group::üì¶ Production Deployment Artifacts"
          echo "Verifying artifacts..."
          ls -la artifacts/
          echo "üìù Source revision: $(cat artifacts/revision.txt)"
          echo "‚úÖ Artifacts verified successfully"
          echo "::endgroup::"
          
  Build_And_Upload_Prod:
    needs: [Setup_Auth, Request_Production_Approval, Build_And_Upload_NonProd]  # Added Build_And_Upload_NonProd to needs
    if: always() && needs.Request_Production_Approval.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      latest_revision: ${{ steps.upload_and_sync.outputs.revision }}
    steps:
      - name: Set Version ID
        id: set-version
        run: |
          echo "VERSION_ID=${{ needs.Request_Production_Approval.outputs.version_id }}" >> $GITHUB_ENV

      - name: Download Artifacts
        uses: actions/download-artifact@v3
        with:
          name: proxy-artifacts-${{ needs.Request_Production_Approval.outputs.version_id }}
          path: artifacts

      - name: Verify Download
        run: |
          echo "::group::üì¶ Verifying Downloaded Artifacts"
          echo "Looking for artifacts with version ID: ${{ needs.Request_Production_Approval.outputs.version_id }}"
          ls -la artifacts/ || echo "Artifacts directory is empty or doesn't exist"
          
          if [ ! -f "artifacts/revision.txt" ]; then
            echo "‚ùå Error: revision.txt not found"
            exit 1
          fi
          
          if [ ! -f "artifacts/proxy-${{ needs.Request_Production_Approval.outputs.version_id }}.zip" ]; then
            echo "‚ùå Error: proxy bundle not found"
            exit 1
          fi
          
          echo "üìù Source revision: $(cat artifacts/revision.txt)"
          echo "‚úÖ Artifacts verified successfully"
          echo "::endgroup::"

      - name: Install apigeecli
        id: install-apigeecli
        uses: nick-invision/retry@v2
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            echo "::group::üîß Installing Apigee CLI"
            mkdir -p $HOME/.apigeecli/bin
            curl -L https://raw.githubusercontent.com/apigee/apigeecli/main/downloadLatest.sh | sh -
            echo "$HOME/.apigeecli/bin" >> $GITHUB_PATH
            echo "‚úÖ apigeecli installed successfully"
            echo "::endgroup::"

      - name: Get GCP Token
        id: get-token
        uses: 'google-github-actions/auth@v1'
        with:
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER_PROD }}
          service_account: ${{ secrets.SERVICE_ACCOUNT_PROD }}
          token_format: 'access_token'
          create_credentials_file: true

      - name: Upload and Sync Revision
        id: upload_and_sync
        run: |
          echo "::group::üì§ Uploading to Production"
          SOURCE_REVISION=$(cat artifacts/revision.txt)
          echo "üìù Target revision: $SOURCE_REVISION"
          
          TOKEN=$(gcloud auth print-access-token)
          
          # Verify bundle exists before attempting upload
          if [ ! -f "artifacts/proxy-${{ needs.Request_Production_Approval.outputs.version_id }}.zip" ]; then
            echo "‚ùå Error: Bundle file not found at expected location"
            ls -la artifacts/
            exit 1
          fi
          
          echo "Beginning upload process..."
          IMPORT_OUTPUT=$($HOME/.apigeecli/bin/apigeecli apis create bundle \
            -n "${{ inputs.proxy_name }}" \
            -p "artifacts/proxy-${{ needs.Request_Production_Approval.outputs.version_id }}.zip" \
            --org "${{ secrets.APIGEE_ORG_PROD }}" \
            --token "$TOKEN")
          
          if [ $? -ne 0 ]; then
            echo "‚ùå Initial upload failed"
            echo "$IMPORT_OUTPUT"
            exit 1
          fi
          
          CURRENT_REVISION=$(echo "$IMPORT_OUTPUT" | grep -oP '"revision":\s*"\K[^"]+')
          echo "Current revision in prod: $CURRENT_REVISION"
          
          # Continue uploading until we reach or exceed the target revision
          while [ "$CURRENT_REVISION" -lt "$SOURCE_REVISION" ]; do
            echo "Uploading to increment revision..."
            IMPORT_OUTPUT=$($HOME/.apigeecli/bin/apigeecli apis create bundle \
              -n "${{ inputs.proxy_name }}" \
              -p "artifacts/proxy-${{ needs.Request_Production_Approval.outputs.version_id }}.zip" \
              --org "${{ secrets.APIGEE_ORG_PROD }}" \
              --token "$TOKEN")
            
            if [ $? -ne 0 ]; then
              echo "‚ùå Upload failed during revision sync"
              echo "$IMPORT_OUTPUT"
              exit 1
            fi
            
            CURRENT_REVISION=$(echo "$IMPORT_OUTPUT" | grep -oP '"revision":\s*"\K[^"]+')
            echo "Updated revision: $CURRENT_REVISION"
          done
          
          echo "‚úÖ Successfully synced revision numbers"
          echo "üìù Final revision: $CURRENT_REVISION"
          echo "revision=$CURRENT_REVISION" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: Verify Final State
        run: |
          echo "::group::‚úîÔ∏è Final Verification"
          echo "Version ID used: ${{ needs.Request_Production_Approval.outputs.version_id }}"
          echo "Final revision: ${{ steps.upload_and_sync.outputs.revision }}"
          echo "‚úÖ Build and upload process completed"
          echo "::endgroup::"
          
  Deploy_To_Production:
    needs: [Build_And_Upload_Prod]
    if: needs.Build_And_Upload_Prod.result == 'success'
    runs-on: ubuntu-latest
    steps:
      - name: Install apigeecli
        id: install-apigeecli
        uses: nick-invision/retry@v2
        with:
          timeout_minutes: 5
          max_attempts: 3
          command: |
            echo "::group::üîß Installing Apigee CLI"
            mkdir -p $HOME/.apigeecli/bin
            curl -L https://raw.githubusercontent.com/apigee/apigeecli/main/downloadLatest.sh | sh -
            echo "$HOME/.apigeecli/bin" >> $GITHUB_PATH
            echo "‚úÖ apigeecli installed successfully"
            echo "::endgroup::"

      - name: Get GCP Token
        id: get-token
        uses: 'google-github-actions/auth@v1'
        with:
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER_PROD }}
          service_account: ${{ secrets.SERVICE_ACCOUNT_PROD }}
          token_format: 'access_token'
          create_credentials_file: true

      - name: Deploy to Production
        run: |
          echo "::group::üöÄ Deploying to Production"
          TOKEN=$(gcloud auth print-access-token)
          
          if [ "${{ inputs.environment_group }}" == "default" ]; then
            DEPLOY_ENV="test-env"
          else
            DEPLOY_ENV="${{ inputs.environment_group }}-test-env"
          fi
          
          REVISION="${{ needs.Build_And_Upload_Prod.outputs.latest_revision }}"
          
          echo "üìç Target Environment: $DEPLOY_ENV"
          echo "üì¶ Deploying revision: $REVISION"
          
          $HOME/.apigeecli/bin/apigeecli apis deploy \
            --name "${{ inputs.proxy_name }}" \
            --org "${{ secrets.APIGEE_ORG_PROD }}" \
            --env "$DEPLOY_ENV" \
            --rev "$REVISION" \
            --token "$TOKEN" \
            --ovr \
            --wait

          if [ $? -eq 0 ]; then
            echo "‚úÖ Successfully deployed to production environment"
          else
            echo "‚ùå Production deployment failed"
            exit 1
          fi
          echo "::endgroup::"

      - name: Post-Deployment Summary
        if: success()
        run: |
          echo "::group::üìã Deployment Summary"
          echo "‚úÖ Production deployment completed successfully"
          echo "üì¶ Proxy: ${{ inputs.proxy_name }}"
          echo "üìù Deployed revision: ${{ needs.Build_And_Upload_Prod.outputs.latest_revision }}"
          echo "üåê Environment: $DEPLOY_ENV"
          echo "‚è±Ô∏è Completed at: $(date)"
          echo "::endgroup::"

  Clean_Old_Versions:
    needs: [Build_And_Upload_NonProd, Build_And_Upload_Prod, Deploy_To_NonProd, Deploy_To_Production]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write
    env:
      KEEP_COUNT: 5
      PROXY_NAME: ${{ inputs.proxy_name }}
      APIGEE_NONPROD_ORG: ${{ secrets.APIGEE_ORG }}
      APIGEE_PROD_ORG: ${{ secrets.APIGEE_ORG_PROD }}
    outputs:
      nonprod_kept: ${{ steps.nonprod-cleanup.outputs.kept-count }}
      nonprod_deleted: ${{ steps.nonprod-cleanup.outputs.deleted-count }}
      nonprod_failed: ${{ steps.nonprod-cleanup.outputs.failed-count }}
      prod_kept: ${{ steps.prod-cleanup.outputs.kept-count }}
      prod_deleted: ${{ steps.prod-cleanup.outputs.deleted-count }}
      prod_failed: ${{ steps.prod-cleanup.outputs.failed-count }}
    steps:
      - name: Set up Google Cloud SDK
        uses: google-github-actions/setup-gcloud@v1

      - name: Non-Prod Auth
        id: nonprod-auth
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER }}
          service_account: ${{ secrets.SERVICE_ACCOUNT }}

      - name: Cleanup Non-Prod Revisions
        id: nonprod-cleanup
        shell: bash {0}
        run: |
          set +e
          
          # Get access token
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          if [ -z "$ACCESS_TOKEN" ]; then
            echo "Failed to get access token"
            echo "kept-count=0" >> $GITHUB_OUTPUT
            echo "deleted-count=0" >> $GITHUB_OUTPUT
            echo "failed-count=0" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "Starting deletion of older revisions for proxy: $PROXY_NAME in Non-Prod"
          
          # Get revisions
          REVISIONS_JSON=$(curl -s -X GET -H "Authorization: Bearer $ACCESS_TOKEN" \
            "https://apigee.googleapis.com/v1/organizations/$APIGEE_NONPROD_ORG/apis/$PROXY_NAME/revisions")
          
          # Convert to array and sort
          readarray -t REVISIONS < <(echo "$REVISIONS_JSON" | jq -r '.[]' | sort -n)
          TOTAL_REVISIONS=${#REVISIONS[@]}
          
          echo "Found $TOTAL_REVISIONS revisions"
          
          # Initialize counters
          DELETED=0
          FAILED=0
          
          if [ "$TOTAL_REVISIONS" -le "$KEEP_COUNT" ]; then
            echo "kept-count=$TOTAL_REVISIONS" >> $GITHUB_OUTPUT
            echo "deleted-count=0" >> $GITHUB_OUTPUT
            echo "failed-count=0" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          DELETE_COUNT=$((TOTAL_REVISIONS - KEEP_COUNT))
          
          # Process revisions to delete
          for ((i=0; i<DELETE_COUNT; i++)); do
            REV="${REVISIONS[$i]}"
            echo "Attempting to delete revision $REV"
            
            STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              "https://apigee.googleapis.com/v1/organizations/$APIGEE_NONPROD_ORG/apis/$PROXY_NAME/revisions/$REV")
            
            if [ "$STATUS_CODE" = "200" ]; then
              ((DELETED++))
              echo "‚úÖ Successfully deleted revision $REV"
            else
              ((FAILED++))
              echo "‚ùå Failed to delete revision $REV (Status: $STATUS_CODE)"
            fi
          done
          
          # Set outputs
          echo "kept-count=$KEEP_COUNT" >> $GITHUB_OUTPUT
          echo "deleted-count=$DELETED" >> $GITHUB_OUTPUT
          echo "failed-count=$FAILED" >> $GITHUB_OUTPUT
          
          # Generate summary
          SUMMARY="Non-Prod Cleanup Summary:\n"
          SUMMARY+="- Total revisions: $TOTAL_REVISIONS\n"
          SUMMARY+="- Kept: $KEEP_COUNT\n"
          SUMMARY+="- Deleted: $DELETED\n"
          SUMMARY+="- Failed: $FAILED\n"
          
          echo "nonprod_summary<<EOF" >> $GITHUB_ENV
          echo -e "$SUMMARY" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

      # Run Prod cleanup regardless of is_production flag if secrets exist
      # Run prod cleanup if non-prod was successful
      - name: Prod Auth
        id: prod-auth
        if: success()
        uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ secrets.WORKLOAD_IDENTITY_PROVIDER_PROD }}
          service_account: ${{ secrets.SERVICE_ACCOUNT_PROD }}
        continue-on-error: true

      - name: Cleanup Prod Revisions
        id: prod-cleanup
        if: steps.prod-auth.outcome == 'success'
        shell: bash {0}
        run: |
          set +e
          
          # Get access token
          ACCESS_TOKEN=$(gcloud auth print-access-token)
          if [ -z "$ACCESS_TOKEN" ]; then
            echo "Failed to get access token"
            echo "kept-count=0" >> $GITHUB_OUTPUT
            echo "deleted-count=0" >> $GITHUB_OUTPUT
            echo "failed-count=0" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "Starting deletion of older revisions for proxy: $PROXY_NAME in Prod"
          
          # Get revisions
          REVISIONS_JSON=$(curl -s -X GET -H "Authorization: Bearer $ACCESS_TOKEN" \
            "https://apigee.googleapis.com/v1/organizations/${{ secrets.APIGEE_ORG_PROD }}/apis/$PROXY_NAME/revisions")
          
          # Get currently deployed revision
          DEPLOYED_JSON=$(curl -s -X GET -H "Authorization: Bearer $ACCESS_TOKEN" \
            "https://apigee.googleapis.com/v1/organizations/${{ secrets.APIGEE_ORG_PROD }}/environments/prod/deployments")
          
          DEPLOYED_REV=$(echo "$DEPLOYED_JSON" | jq -r --arg PROXY "$PROXY_NAME" '.deployments[] | select(.apiProxy==$PROXY) | .revision // empty')
          echo "Currently deployed revision: ${DEPLOYED_REV:-None}"
          
          # Convert to array and sort in reverse order (newest first)
          readarray -t REVISIONS < <(echo "$REVISIONS_JSON" | jq -r '.[]' | sort -nr)
          TOTAL_REVISIONS=${#REVISIONS[@]}
          
          echo "Found $TOTAL_REVISIONS revisions"
          echo "Keeping $KEEP_COUNT most recent revisions and deployed revision"
          
          # Initialize counters and arrays
          DELETED=0
          FAILED=0
          KEPT=0
          declare -a REVISIONS_TO_KEEP
          declare -a REVISIONS_TO_DELETE
          
          # First, ensure we keep the deployed revision if it exists
          if [ ! -z "$DEPLOYED_REV" ]; then
            REVISIONS_TO_KEEP+=("$DEPLOYED_REV")
            ((KEPT++))
            echo "Keeping deployed revision: $DEPLOYED_REV"
          fi
          
          # Then keep the most recent revisions
          for REV in "${REVISIONS[@]}"; do
            if [ $KEPT -lt $KEEP_COUNT ]; then
              # Only add to keep list if it's not already there (not the deployed revision)
              if [[ ! " ${REVISIONS_TO_KEEP[@]} " =~ " ${REV} " ]]; then
                REVISIONS_TO_KEEP+=("$REV")
                ((KEPT++))
                echo "Keeping recent revision: $REV"
              fi
            else
              # Only add to delete list if it's not in keep list
              if [[ ! " ${REVISIONS_TO_KEEP[@]} " =~ " ${REV} " ]]; then
                REVISIONS_TO_DELETE+=("$REV")
              fi
            fi
          done
          
          echo "Revisions to keep: ${REVISIONS_TO_KEEP[*]}"
          echo "Revisions to delete: ${REVISIONS_TO_DELETE[*]}"
          
          # Delete old revisions
          for REV in "${REVISIONS_TO_DELETE[@]}"; do
            echo "Attempting to delete revision $REV"
            
            STATUS_CODE=$(curl -s -o /dev/null -w "%{http_code}" -X DELETE \
              -H "Authorization: Bearer $ACCESS_TOKEN" \
              "https://apigee.googleapis.com/v1/organizations/${{ secrets.APIGEE_ORG_PROD }}/apis/$PROXY_NAME/revisions/$REV")
            
            if [ "$STATUS_CODE" = "200" ]; then
              ((DELETED++))
              echo "‚úÖ Successfully deleted revision $REV"
            else
              ((FAILED++))
              echo "‚ùå Failed to delete revision $REV (Status: $STATUS_CODE)"
            fi
          done
          
          # Set outputs
          echo "kept-count=${#REVISIONS_TO_KEEP[@]}" >> $GITHUB_OUTPUT
          echo "deleted-count=$DELETED" >> $GITHUB_OUTPUT
          echo "failed-count=$FAILED" >> $GITHUB_OUTPUT
          
          # Generate summary
          SUMMARY="Production Cleanup Summary:\n"
          SUMMARY+="- Total revisions before cleanup: $TOTAL_REVISIONS\n"
          SUMMARY+="- Currently deployed revision: ${DEPLOYED_REV:-None}\n"
          SUMMARY+="- Versions kept ($KEPT): ${REVISIONS_TO_KEEP[*]}\n"
          SUMMARY+="- Versions deleted ($DELETED): ${REVISIONS_TO_DELETE[*]}\n"
          SUMMARY+="- Failed deletions ($FAILED)\n"
          
          echo "prod_summary<<EOF" >> $GITHUB_ENV
          echo -e "$SUMMARY" >> $GITHUB_ENV
          echo "EOF" >> $GITHUB_ENV

          
  Deployment_Summary:
    needs: [validate_deployment_inputs, Setup_Auth, Validate_API_Proxy, Build_And_Upload_NonProd, Deploy_To_NonProd, Verify_NonProd_Deployment, Request_Production_Approval, Build_And_Upload_Prod, Deploy_To_Production, Clean_Old_Versions]
    if: always()
    runs-on: ubuntu-latest
    permissions:
      checks: write
      contents: read
      id-token: write
      deployments: write
      issues: write
    steps:
      - name: Generate Detailed Logs
        run: |
          # Create logs directory and file
          mkdir -p logs
          LOG_FILE="logs/deployment_log_${{ inputs.proxy_name }}_$(date +%Y%m%d_%H%M%S).txt"
          
          {
            echo "============================================================"
            echo "                 APIGEE DEPLOYMENT LOGS                      "
            echo "============================================================"
            echo ""
            echo "Generated at: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "Proxy Name: ${{ inputs.proxy_name }}"
            echo "Environment Group: ${{ inputs.environment_group }}"
            echo "Environment Type: ${{ inputs.environment_type }}"
            echo "Is Production: ${{ inputs.is_production }}"
            echo ""
            
            echo "============================================================"
            echo "                 VALIDATION PHASE                            "
            echo "============================================================"
            echo "Status: ${{ needs.validate_deployment_inputs.result }}"
            echo "Can Proceed: ${{ needs.validate_deployment_inputs.outputs.can_proceed }}"
            echo "Deployment Type: ${{ needs.validate_deployment_inputs.outputs.deployment_type }}"
            echo "Environment: ${{ needs.validate_deployment_inputs.outputs.environment }}"
            echo ""
            
            echo "============================================================"
            echo "                 AUTHENTICATION PHASE                        "
            echo "============================================================"
            echo "Status: ${{ needs.Setup_Auth.result }}"
            echo ""
            
            echo "============================================================"
            echo "                 BUILD AND UPLOAD PHASE                      "
            echo "============================================================"
            echo "Non-Prod Build Status: ${{ needs.Build_And_Upload_NonProd.result }}"
            echo "Version ID: ${{ needs.Build_And_Upload_NonProd.outputs.version_id }}"
            echo "Non-Prod Revision: ${{ needs.Build_And_Upload_NonProd.outputs.latest_revision }}"
            
            if [[ "${{ inputs.is_production }}" == "true" ]]; then
              echo ""
              echo "Production Build Status: ${{ needs.Build_And_Upload_Prod.result }}"
              echo "Production Revision: ${{ needs.Build_And_Upload_Prod.outputs.latest_revision }}"
            fi
            echo ""
            
            echo "============================================================"
            echo "                 DEPLOYMENT PHASE                            "
            echo "============================================================"
            echo "Non-Prod Deployment Status: ${{ needs.Deploy_To_NonProd.result }}"
            echo "Non-Prod Verification Status: ${{ needs.Verify_NonProd_Deployment.result }}"
            
            if [[ "${{ inputs.is_production }}" == "true" ]]; then
              echo ""
              echo "Production Approval Status: ${{ needs.Request_Production_Approval.result }}"
              echo "Production Deployment Status: ${{ needs.Deploy_To_Production.result }}"
            fi
            echo ""
            
            echo "============================================================"
            echo "                 DEPLOYMENT SUMMARY                          "
            echo "============================================================"
            echo "Final Status: ${{ needs.Deploy_To_NonProd.result }}"
            echo "Deployment Completed at: $(date '+%Y-%m-%d %H:%M:%S')"
            echo "GitHub Run URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
            
          } > "$LOG_FILE"
          
          echo "log_file=$LOG_FILE" >> $GITHUB_ENV

      - name: Generate Step Summary
        env:
          PROXY_NAME: ${{ inputs.proxy_name }}
          ENV_GROUP: ${{ inputs.environment_group }}
          ENV_TYPE: ${{ inputs.environment_type }}
          VERSION_ID: ${{ needs.Build_And_Upload_NonProd.outputs.version_id }}
        run: |
          {
            echo "## üì¶ Version Information"
            echo "| Environment | Version ID |"
            echo "|-------------|------------|"
            echo "| Non-Production | \`$VERSION_ID\` |"
            echo "| Production | \`$VERSION_ID\` |"
          } >> $GITHUB_STEP_SUMMARY

      - name: Create Email Notification
        uses: actions/github-script@v7
        env:
          PROXY_NAME: ${{ inputs.proxy_name }}
          ENV_GROUP: ${{ inputs.environment_group }}
          ENV_TYPE: ${{ inputs.environment_type }}
          NONPROD_DEPLOY_RESULT: ${{ needs.Deploy_To_NonProd.result }}
          NONPROD_REVISION: ${{ needs.Build_And_Upload_NonProd.outputs.latest_revision }}
          PROD_DEPLOY_RESULT: ${{ needs.Deploy_To_Production.result }}
          PROD_REVISION: ${{ needs.Build_And_Upload_Prod.outputs.latest_revision }}
          VERSION_ID: ${{ needs.Build_And_Upload_NonProd.outputs.version_id }}
          LOG_FILE: ${{ env.log_file }}
        with:
          script: |
            const fs = require('fs');
            const logContent = fs.readFileSync(process.env.LOG_FILE, 'utf8');
            
            const summary = `# üöÄ Apigee Proxy Deployment Summary

            @${context.actor}, your deployment has completed!

            ## üìã Deployment Status
            | Category | Details |
            |----------|---------|
            | Proxy Name | \`${process.env.PROXY_NAME}\` |
            | Environment | \`${process.env.ENV_GROUP}-${process.env.ENV_TYPE}\` |
            | Non-Prod Status | ${process.env.NONPROD_DEPLOY_RESULT === 'success' ? '‚úÖ Success' : '‚ùå Failed'} |
            | Non-Prod Revision | \`${process.env.NONPROD_REVISION}\` |
            ${process.env.PROD_REVISION ? `| Prod Status | ${process.env.PROD_DEPLOY_RESULT === 'success' ? '‚úÖ Success' : '‚ùå Failed'} |
            | Prod Revision | \`${process.env.PROD_REVISION}\` |` : ''}

            ## üì¶ Version Details
            | Environment | Version ID |
            |-------------|------------|
            | Non-Production | \`${process.env.VERSION_ID}\` |
            | Production | \`${process.env.VERSION_ID}\` |

            ## üìù Detailed Logs
            <details>
            <summary>Click to expand deployment logs</summary>

            \`\`\`
            ${logContent}
            \`\`\`

            </details>

            ## üîó Details
            [View Full Deployment Run](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})

            ---
            ‚ö° *Generated at ${new Date().toISOString()}*`;

            await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Deployment Summary: ${process.env.PROXY_NAME} (${new Date().toISOString().split('T')[0]})`,
              body: summary,
              labels: ['deployment', process.env.NONPROD_DEPLOY_RESULT === 'success' ? 'success' : 'failed']
            });

      - name: Save Log File
        uses: actions/upload-artifact@v3
        with:
          name: deployment-logs-${{ needs.Build_And_Upload_NonProd.outputs.version_id }}
          path: ${{ env.log_file }}
          retention-days: 30

      - name: Notify in GitHub UI
        run: |
          if [[ "${{ needs.Deploy_To_NonProd.result }}" == "success" ]]; then
            echo "::notice title=‚úÖ Deployment Successful::Deployment of ${{ inputs.proxy_name }} has completed successfully. Check your notifications for details."
          else
            echo "::warning title=‚ùå Deployment Issue::Deployment of ${{ inputs.proxy_name }} has completed with issues. Check your notifications for details."
          fi
